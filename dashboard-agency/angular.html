<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guida a Frameworks, Angular e React</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
</head>

<body class="bg-gray-100 text-gray-900 font-sans">
    <div class="w-full mx-auto px-4 py-12">
        <h1 class="text-3xl font-bold text-center text-purple-700 mb-12">Framework e Librerie: Angular vs React</h1>

        <div class="space-y-8">
            <section>
                <h2 class="text-2xl font-bold text-purple-600">Cosa è un Framework e cosa è una Libreria</h2>
                <p class="mt-2 text-lg text-gray-700">Un <strong>framework</strong> è un insieme coesivo di librerie e
                    un ambiente che fornisce una struttura di base per lo sviluppo di software. I framework dettano la
                    struttura e il flusso dell'applicazione, 'guidando' lo sviluppatore su come costruire il software.
                    Una <strong>libreria</strong>, invece, è una raccolta di funzioni e utilità che gli sviluppatori
                    possono scegliere di usare o meno, senza una struttura imposta.</p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">Cosa è Angular, come e quando nasce</h2>
                <p class="mt-2 text-lg text-gray-700">Angular è un framework di sviluppo front-end open-source
                    sviluppato da Google. La sua prima versione è stata rilasciata nel 2010 come AngularJS, con
                    l'intento di semplificare lo sviluppo e il testing di applicazioni single-page. AngularJS è stato
                    completamente riscritto nel 2016 e ribattezzato semplicemente Angular, introducendo un'architettura
                    basata su componenti.</p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">Differenze cruciali tra Angular e React</h2>
                <ul class="list-disc list-inside mt-2 text-lg text-gray-700">
                    <li>
                        <strong>Architettura:</strong> Angular è un framework completo che offre tutto il necessario per
                        sviluppare applicazioni complesse, includendo gestione dello stato, routing e moduli
                        pre-costruiti. Invece, React è una libreria che si concentra sulla costruzione dell'interfaccia
                        utente e richiede l'integrazione con altre librerie per il routing, la gestione dello stato, e
                        altre funzionalità.
                    </li>
                    <li>
                        <strong>Linguaggio:</strong> Angular è costruito attorno a TypeScript, che è essenzialmente
                        JavaScript con tipizzazione statica. Questo offre una maggiore sicurezza del codice e migliora
                        la manutenibilità e l'affidabilità del software. React è basato su JavaScript e non impone l'uso
                        di TypeScript, anche se può essere integrato per offrire benefici simili.
                    </li>
                    <li>
                        <strong>Data Binding:</strong> Angular utilizza un data binding bidirezionale che permette di
                        sincronizzare automaticamente i dati tra il modello e la vista. Questo può rendere più semplice
                        la gestione di form e componenti complessi. React, d'altra parte, adotta un approccio di flusso
                        di dati unidirezionale (one-way data flow) che migliora la prevedibilità e la facilità di debug
                        del codice.
                    </li>
                    <li>
                        <strong>Performance:</strong> Angular ha meccanismi interni per ottimizzare le performance, ma
                        può risultare più pesante per applicazioni molto grandi o complesse. React è generalmente più
                        leggero e può essere più veloce grazie all'utilizzo di una virtual DOM che riduce gli
                        aggiornamenti del DOM reale.
                    </li>
                    <li>
                        <strong>Ecosistema e Comunità:</strong> Angular gode del supporto diretto di Google. React,
                        supportato da Facebook.
                    </li>
                </ul>
                <p class="mt-2 text-lg text-gray-700">La scelta tra Angular e React dipende dalle necessità specifiche
                    del progetto, dalle competenze del team, dalla complessità dell'applicazione, e dalle preferenze per
                    quanto riguarda la struttura del codice e la gestione dello stato. Angular potrebbe essere
                    preferibile per progetti enterprise di grande scala che beneficiano di un framework completo e
                    strutturato, mentre React potrebbe essere la scelta migliore per progetti che richiedono maggiore
                    flessibilità e una rapida prototipazione.</p>
            </section>


            <section>
                <h2 class="text-2xl font-bold text-purple-600">Cosa rende lo sviluppo con Angular bello e interessante
                </h2>
                <p class="mt-2 text-lg text-gray-700">Angular è ammirato per il suo approccio olistico allo sviluppo di
                    applicazioni. La sua architettura basata su componenti, il supporto integrato per la programmazione
                    reattiva con RxJS, e le funzionalità avanzate di routing e form rendono Angular un potente strumento
                    per costruire applicazioni robuste e scalabili.</p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">Perché si dice che la curva di apprendimento di Angular
                    sia più ripida rispetto a React</h2>
                <p class="mt-2 text-lg text-gray-700">Angular è noto per avere una curva di apprendimento più ripida a
                    causa della sua natura complessiva e delle molteplici funzionalità che richiedono una comprensione
                    iniziale più approfondita. La necessità di conoscere TypeScript e concetti come dependency
                    injection, moduli e decorators può intimidire i nuovi sviluppatori.</p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">Similitudini tra Angular e OOP/Java</h2>
                <p class="mt-2 text-lg text-gray-700">Angular e Java condividono molti principi dell'OOP (programmazione
                    orientata agli oggetti). Entrambi utilizzano classi, oggetti e moduli per organizzare il codice.
                    Angular incoraggia l'uso di classi per componenti, servizi e moduli, simili agli approcci utilizzati
                    in Java.</p>
            </section>
            <section>
                <h2 class="text-2xl font-bold text-purple-600">Approfondimento su TypeScript</h2>
                <p class="mt-2 text-lg text-gray-700">TypeScript è una sovrapposizione di JavaScript che introduce
                    tipizzazione statica. Questo significa che le variabili e le espressioni sono controllate in fase di
                    sviluppo, riducendo gli errori di runtime. Angular utilizza TypeScript per migliorare la
                    manutenibilità e la robustezza del codice, ma richiede agli sviluppatori di apprendere nuovi
                    concetti e sintassi, aumentando la complessità iniziale di apprendimento.</p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">Dependency Injection in Angular</h2>
                <p class="mt-2 text-lg text-gray-700">La dependency injection è un design pattern centralizzato in
                    Angular che promuove un'alta coesione e un basso accoppiamento tra le classi e i loro consumatori.
                    In Angular, oggetti come servizi possono essere "iniettati" in componenti senza la necessità di
                    crearli manualmente, facilitando così la gestione delle dipendenze ma introducendo una curva di
                    apprendimento per chi non è familiare con questo pattern.</p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">Moduli in Angular</h2>
                <p class="mt-2 text-lg text-gray-700">I moduli in Angular organizzano l'applicazione in blocchi
                    funzionali, ciascuno con componenti, servizi, filtri, direttive, e altro ancora, separati per
                    funzionalità. Questo organizzazione modulare aiuta nella riutilizzabilità del codice e nel lazy
                    loading, ma richiede una comprensione approfondita di come i moduli interagiscono e vengono
                    caricati.</p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">Decorators e Metaprogrammazione</h2>
                <p class="mt-2 text-lg text-gray-700">Angular fa uso di decorators per arricchire le classi e le
                    proprietà con funzionalità aggiuntive. Questi decorators, come @Component, @NgModule, o @Injectable,
                    definiscono e modificano il comportamento delle classi senza alterarne il codice sorgente,
                    introducendo un ulteriore livello di astrazione che può complicare l'apprendimento iniziale per i
                    nuovi sviluppatori.</p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">@Component</h2>
                <p class="mt-2 text-lg text-gray-700">Il decorator <code>@Component</code> definisce una classe come
                    componente Angular. Esso associa metadati alla classe che informano Angular su come istanziare e
                    utilizzare il componente. Di seguito un esempio:</p>
                <pre class="bg-gray-100 p-4 mt-2"><code>@Component({
              selector: 'app-example',
              templateUrl: './example.component.html',
              styleUrls: ['./example.component.css']
            })
            export class ExampleComponent {
              // Logica del componente
            }</code></pre>
                <p>Qui, <code>selector</code> definisce il tag HTML personalizzato per il componente,
                    <code>templateUrl</code> specifica il percorso del file HTML per il template, e
                    <code>styleUrls</code> indica i file CSS per gli stili specifici del componente.
                </p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">@NgModule</h2>
                <p class="mt-2 text-lg text-gray-700">Il decorator <code>@NgModule</code> organizza il codice correlato
                    in blocchi funzionali, definendo un contesto per il compilatore Angular. Ecco un esempio di come
                    definire un modulo:</p>
                <pre class="bg-gray-100 p-4 mt-2"><code>@NgModule({
              declarations: [
                ExampleComponent
              ],
              imports: [
                BrowserModule
              ],
              providers: [],
              bootstrap: [AppComponent]
            })
            export class AppModule { }</code></pre>
                <p>Il modulo dichiara quali componenti appartengono ad esso (<code>declarations</code>), quali altri
                    moduli sono necessari (<code>imports</code>), quali servizi fornisce (<code>providers</code>), e
                    quale componente avvia l'applicazione (<code>bootstrap</code>).</p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">@Injectable</h2>
                <p class="mt-2 text-lg text-gray-700">Il decorator <code>@Injectable</code> marca una classe come
                    disponibile per essere fornita e iniettata come dipendenza. È comunemente usato per definire
                    servizi. Ecco un esempio di un servizio in Angular:</p>
                <pre class="bg-gray-100 p-4 mt-2"><code>@Injectable({
              providedIn: 'root'
            })
            export class ExampleService {
              constructor(private http: HttpClient) { }
              // Metodi del servizio
            }</code></pre>
                <p>Questo servizio può ora essere iniettato in qualsiasi componente dell'applicazione, promuovendo una
                    progettazione di alta qualità e una facile manutenzione.</p>
            </section>



            <section>
                <h2 class="text-2xl font-bold text-purple-600">Direttive Native di Angular</h2>
                <p class="mt-2 text-lg text-gray-700">Angular include diverse direttive native che possono essere
                    utilizzate per manipolare il DOM in modi diversi. Le più comuni includono <code>ngModel</code>,
                    <code>ngClass</code>, e <code>ngIf</code>. Ecco un esempio pratico di come si utilizza
                    <code>ngIf</code> per il controllo condizionale del rendering degli elementi:
                </p>
                <pre
                    class="bg-gray-100 p-4 mt-2"><code>&lt;div *ngIf="isVisible"&gt;Questo elemento viene mostrato solo se 'isVisible' è true.&lt;/div&gt;</code></pre>
                <p>La direttiva <code>ngIf</code> aggiunge o rimuove elementi dall'HTML basato su una condizione
                    booleana. È molto utile per controllare dinamicamente il contenuto visibile dell'interfaccia utente.
                </p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">Utilizzo di *ngFor in Angular</h2>
                <p class="mt-2 text-lg text-gray-700">La direttiva <code>*ngFor</code> è usata per ripetere un template
                    per ogni elemento in un array. Questo rende molto semplice visualizzare liste di dati dinamici. Di
                    seguito è mostrato un esempio di come utilizzare <code>*ngFor</code> per visualizzare una lista di
                    nomi:</p>
                <pre class="bg-gray-100 p-4 mt-2"><code>&lt;ul&gt;
              &lt;li *ngFor="let name of names"&gt;{{ name }}&lt;/li&gt;
            &lt;/ul&gt;</code></pre>
                <p>Qui, <code>names</code> dovrebbe essere un array di stringhe definito nel componente TypeScript di
                    Angular. La direttiva <code>*ngFor</code> cicla attraverso l'array e crea un nuovo elemento
                    <code>&lt;li&gt;</code> per ogni elemento nell'array.
                </p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">Binding Unidirezionale in Angular</h2>
                <p class="mt-2 text-lg text-gray-700">Il binding unidirezionale (One-way binding) in Angular consente di
                    inviare dati da un componente al template (vista). Questo si realizza tramite l'interpolazione e le
                    property bindings. Ecco un esempio di interpolazione, dove i dati vengono inviati dal componente al
                    template HTML:</p>
                <pre class="bg-gray-100 p-4 mt-2"><code>{{ data }}</code></pre>
                <p>Un altro esempio di binding unidirezionale è il property binding, che consente di impostare proprietà
                    di elementi HTML o di altri componenti Angular:</p>
                <pre
                    class="bg-gray-100 p-4 mt-2"><code>&lt;div [title]="data"&gt;Ciao, sono un tooltip!&lt;/div&gt;</code></pre>
                <p>Qui, il valore della proprietà <code>title</code> di un elemento <code>&lt;div&gt;</code> è legato
                    alla variabile <code>data</code> nel componente Angular.</p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">Binding Bidirezionale in Angular</h2>
                <p class="mt-2 text-lg text-gray-700">Il binding bidirezionale (Two-way binding) in Angular consente una
                    sincronizzazione immediata tra la vista e il modello di dati, il che significa che ogni cambiamento
                    ai dati nel modello aggiorna la vista, e ogni cambiamento nella vista aggiorna il modello. Questo è
                    spesso usato nei form. Angular realizza il binding bidirezionale usando la direttiva
                    <code>[(ngModel)]</code>. Ecco un esempio:
                </p>
                <pre class="bg-gray-100 p-4 mt-2"><code>&lt;input type="text" [(ngModel)]="user.name"&gt;</code></pre>
                <p>In questo esempio, il valore dell'<code>input</code> è legato alla proprietà <code>user.name</code>.
                    Qualsiasi cambiamento all'input da parte dell'utente aggiornerà immediatamente la proprietà
                    <code>user.name</code> nel componente, e qualsiasi aggiornamento a <code>user.name</code> nel
                    componente sarà riflesso automaticamente nell'input.
                </p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">Routing in Angular</h2>
                <p class="mt-2 text-lg text-gray-700">Il routing in Angular consente di navigare tra le diverse viste
                    dell'applicazione senza dover ricaricare la pagina. Angular offre un modulo di routing che permette
                    di definire le rotte e i relativi componenti. Ecco un esempio di come definire le rotte in Angular:
                </p>
                <pre class="bg-gray-100 p-4 mt-2"><code>@NgModule({
              imports: [RouterModule.forRoot([
                { path: 'home', component: HomeComponent },
                { path: 'about', component: AboutComponent },
                { path: 'contact', component: ContactComponent }
              ])],
              exports: [RouterModule]
            })
            export class AppRoutingModule { }</code></pre>
                <p>Qui, abbiamo definito tre rotte: <code>/home</code>, <code>/about</code>, e <code>/contact</code>,
                    ciascuna associata a un componente specifico. Queste rotte possono essere navigate tramite link o
                    programmazione.</p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">Gestione degli Eventi in Angular</h2>
                <p class="mt-2 text-lg text-gray-700">Angular permette di gestire gli eventi HTML come il click, il
                    focus, il submit, e altri, utilizzando il decorator <code>@HostListener</code>. Ad esempio, per
                    gestire un evento di click su un elemento, puoi fare quanto segue:</p>
                <pre class="bg-gray-100 p-4 mt-2"><code>@Component({
              selector: 'app-example',
              template: '&lt;button&gt;Clicca qui&lt;/button&gt;'
            })
            export class ExampleComponent {
              @HostListener('click') onClick() {
                console.log('Elemento cliccato!');
              }
            }</code></pre>
                <p>In questo esempio, il metodo <code>onClick</code> verrà chiamato quando l'elemento viene cliccato,
                    stampando "Elemento cliccato!" nella console.</p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">Servizi in Angular</h2>
                <p class="mt-2 text-lg text-gray-700">I servizi in Angular sono classi che forniscono funzionalità
                    condivise tra diversi componenti. Sono utilizzati per la logica di business, l'accesso ai dati, la
                    comunicazione con i server, e altre operazioni che non appartengono direttamente ai componenti. Ecco
                    un esempio di come definire e utilizzare un servizio in Angular:</p>
                <pre class="bg-gray-100 p-4 mt-2"><code>@Injectable({
              providedIn: 'root'
            })
            export class ExampleService {
              getData() {
                return ['Dato 1', 'Dato 2', 'Dato 3'];
              }
            }</code></pre>
                <p>Questo servizio può essere iniettato in qualsiasi componente Angular per accedere ai dati forniti dal
                    metodo <code>getData</code>.</p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">Creazione di Direttive Personalizzate</h2>
                <p class="mt-2 text-lg text-gray-700">Oltre alle direttive predefinite, Angular consente di creare
                    direttive personalizzate per estendere il comportamento degli elementi HTML. Una direttiva
                    personalizzata è definita usando il decorator <code>@Directive</code>. Qui vediamo un esempio di una
                    direttiva semplice che cambia il colore di testo di un elemento HTML quando viene cliccato:</p>
                <pre class="bg-gray-100 p-4 mt-2"><code>@Directive({
              selector: '[appChangeColor]'
            })
            export class ChangeColorDirective {
              constructor(private el: ElementRef) {
                this.el.nativeElement.style.color = 'blue';
              }
            
              @HostListener('click') onClick() {
                this.el.nativeElement.style.color = this.el.nativeElement.style.color === 'blue' ? 'red' : 'blue';
              }
            }</code></pre>
                <p>Questa direttiva può essere applicata a qualsiasi elemento HTML come segue:</p>
                <pre
                    class="bg-gray-100 p-4 mt-2"><code>&lt;div appChangeColor&gt;Clicca qui per cambiare colore!&lt;/div&gt;</code></pre>
                <p>Quando l'elemento è cliccato, il colore del testo cambia da blu a rosso e viceversa.</p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">Utilizzo delle Pipe in Angular</h2>
                <p class="mt-2 text-lg text-gray-700">Le pipe in Angular sono utilizzate per trasformare i dati
                    visualizzati nei template. Angular offre diverse pipe integrate, come <code>date</code>,
                    <code>currency</code>, <code>uppercase</code> e <code>lowercase</code>. Ad esempio, per trasformare
                    una data in un formato leggibile, puoi usare la pipe <code>date</code> come segue:
                </p>
                <pre class="bg-gray-100 p-4 mt-2"><code>{{ today | date:'fullDate' }}</code></pre>
                <p>Questo codice prende la variabile <code>today</code>, che è una data, e la formatta in un formato
                    completo, come "domenica, 29 aprile 2024".</p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">Creazione di Pipe Personalizzate</h2>
                <p class="mt-2 text-lg text-gray-700">Oltre alle pipe predefinite, Angular permette di creare pipe
                    personalizzate per soddisfare esigenze specifiche. Per esempio, se vuoi creare una pipe che
                    raddoppia un numero, puoi definirla così:</p>
                <pre class="bg-gray-100 p-4 mt-2"><code>@Pipe({
              name: 'double'
            })
            export class DoublePipe implements PipeTransform {
              transform(value: number): number {
                return value * 2;
              }
            }</code></pre>
                <p>Puoi poi utilizzare questa pipe nel tuo template per raddoppiare il valore di una variabile numerica:
                </p>
                <pre class="bg-gray-100 p-4 mt-2"><code>{{ number | double }}</code></pre>
                <p>Questa pipe personalizzata prende un numero, lo trasforma raddoppiandolo, e restituisce il risultato
                    che verrà mostrato nel template.</p>
            </section>


            <section>
                <h2 class="text-2xl font-bold text-purple-600">Template-driven Forms</h2>
                <p class="mt-2 text-lg text-gray-700">I Template-driven forms sono un approccio semplice e meno verboso
                    per la creazione di form in Angular, ideali per scenari meno complessi. Questo approccio utilizza
                    direttive come <code>ngModel</code> e si basa molto sul DOM per la gestione dello stato del form.
                    Ecco un esempio:</p>
                <pre class="bg-gray-100 p-4 mt-2"><code>&lt;form (ngSubmit)="onSubmit()" #form="ngForm"&gt;
              &lt;label for="name"&gt;Name:&lt;/label&gt;
              &lt;input type="text" id="name" [(ngModel)]="user.name" name="name" required&gt;
              &lt;button type="submit" [disabled]="!form.valid"&gt;Submit&lt;/button&gt;
            &lt;/form&gt;</code></pre>
                <p>In questo esempio, il modello <code>user.name</code> è legato all'input tramite <code>ngModel</code>.
                    La validità del form è controllata tramite <code>form.valid</code>, e il form può essere inviato
                    solo se tutti i campi richiesti sono validi.</p>
            </section>

            <section>
                <h2 class="text-2xl font-bold text-purple-600">Reactive Forms</h2>
                <p class="mt-2 text-lg text-gray-700">I Reactive forms offrono un controllo più granulare e sono più
                    scalabili, ideali per gestire form complessi con molte validazioni personalizzate. Questo approccio
                    utilizza classi come <code>FormControl</code>, <code>FormGroup</code>, e <code>FormArray</code> per
                    tracciare il valore e lo stato di validazione dei form. Ecco un esempio:</p>
                <pre class="bg-gray-100 p-4 mt-2"><code>import { Component } from '@angular/core';
            import { FormGroup, FormControl, Validators } from '@angular/forms';
            
            @Component({
              selector: 'app-reactive-form',
              template: `
                &lt;form [formGroup]="profileForm" (ngSubmit)="onSubmit()"&gt;
                  &lt;label for="first-name"&gt;First Name:&lt;/label&gt;
                  &lt;input formControlName="firstName" id="first-name" required&gt;
                  &lt;label for="last-name"&gt;Last Name:&lt;/label&gt;
                  &lt;input formControlName="lastName" id="last-name" required&gt;
                  &lt;button type="submit" [disabled]="!profileForm.valid"&gt;Submit&lt;/button&gt;
                &lt;/form&gt;
              `
            })
            export class ReactiveFormComponent {
              profileForm = new FormGroup({
                firstName: new FormControl('', [Validators.required]),
                lastName: new FormControl('', [Validators.required])
              });
            
              onSubmit() {
                console.log(this.profileForm.value);
              }
            }</code></pre>
                <p>In questo esempio, ogni campo del form è gestito da un <code>FormControl</code> che fa parte di un
                    <code>FormGroup</code>. La validazione è gestita direttamente all'interno del form control, rendendo
                    le validazioni più reattive e dinamiche.
                </p>
            </section>

            <script src="https://cdn.tailwindcss.com"></script>
        </div>
    </div>
</body>

</html>